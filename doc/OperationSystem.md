## 1 并发

### 1.1 Semaphore (信号量)

信号量的提出是为了解决同步不同执行线程问题.信号量是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为P和V：

- $P(s)$: 如果s是非零的，那么P将s减一，并且立即返回。如果s为零，那么就挂起这个线程，直到s变为非零，而一个V操作会重启这个线程。在重启之后，P操作将s减1，并将控制返回给调用者。

- $V(s)$: V操作将s加1.如果有任何线程柱塞在P操作等待s变成非零，那么V操作会重启这些线程中的一个，然后该线程将s减1，完成它的P操作。

P和V的定义确保了一个正在运行的程序绝不可能进入这样一种状态, 也就是一个正确初始化了的信号量一个负值。这个属性称为信号量不变性(semaphore invariant).

### 1.2 使用信号量来实现互斥

信号量提供了一种很方便的方法来确保对共享变量的互斥访问。基本思想是将每个共享变量（或者一组相关的共享变量）与一个信号量s（初始为1）联系起来，然后用$P(s)$和$V(s)$操作将相应的临界区包围起来。


以这种方式来保护共享变量的信号量叫做二元信号量(binary semaphore) , 因为它的值总是0或者1 。以提供互斥为目的的二元信号量常常也称为互斥锁( mutex ) 。在一个互斥锁上执行P操作称为对互斥锁加 锁。类似地, 执行V操作称为对互斥锁解锁 对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。一个被用作一组可用资源的计数器的信号量被称为计数信号量。

### 1.3 生产者-消费者问题

生产者和消费者线程共享一个有n个槽的有限缓冲区。生产者线程反复地生成新地项目（item），并把它们插入到缓冲区中。消费者不断地从缓冲区取出这些项目，然后消费（使用）它们。也可能有多个生产者和消费者的变种。

因为插入和取出项目都涉及更新共享变扯, 所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的, 我们还需要调度对缓冲区的访问 。如果缓冲区是满的(没有空的槽位), 那么生产者必须等待直到有一个槽位变为可用。与之相似, 如果缓冲区是空的(没有可取用的项目), 那么消费者必须等待直到有一个项目变为可用。

### 1.4 读者-写者问题

读者-写者问题是互斥问题的一个概述。一组并发的线程要访问一个共享变量，例如一个主存中的数据结构，或者一个磁盘上的数据库。有些线程只读对象，而其他线程只修改对象。修改对象的线程叫做写者。只读对象的线程叫做读者。写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。一般来说，有无限多个并发的读者和写者。

**读者-写者变种**

1. 读者优先,要求不要让读者等待，除非已经把使用对象的权限赋予了有一个写者。换句话说，读者不会因为有一个写者在等待而等待。

2. 写者优先,要求一旦一个写者准备好可以写，它就会尽可能快地完成它地写操作。同第一类问题不同，在一个写者后到达地读者必须等待，即是这个写者也是在等待。

*问题*

对这两种读者-写者问题地正确解答可能导致饥饿(starvation),饥饿就是一个线程无限期地阻塞，无法进展。

如: 如果有读者不断地到达，写者就可能无限期地等待。

## 2 其他并发问题 
### 2.1 线程安全

一个函数被称为*线程安全*(thread-safe),当且仅当被多个并发线程反复地调用时，它会一直产生正确地结果。如果一个函数不是线程安全的，我们就说它是*线程不安全的*(thread-unsafe).

**四个（不相交的）线程不安全函数类**

1. 不保护共享变量的函数
2. 保持跨越多个调用的状态的函数
3. 返回指向静态变量的指针的函数

某些函数将结算结果放在一个static变量中，然后返回一个指向这个变量的指针。如何在并发线程中调用这些函数，可能发生灾难，因为正在被一个线程使用的结果会被另一个线程悄悄地覆盖了。

4. 调用线程不安全的函数

### 2.2 可重入性

可重入函数(reentrant function)是一种线程安全函数。它的特点在于当它们被多个线程调用时，不会引用任何共享函数。

下面`rand_r`函数是一个rand函数的一个可重入的版本。关键思想是我们一个调用者传递进来的指针取代了静态的next变量。

```c

int rand_r(unsigned int *nextp){
  *nextp = *nextp * 1103515245 + 12345;
  return (unsigned int) (*nextp / 65536) % 32768;
}

```

如果所有的函数参数都是传值传递的（即没有指针），并且所有的数据引用都是本地的自动栈变量（及没有引用静态变量或全局变量），那么函数就是*显示可重入的*(explicitly reentrant)，也就是说，无论它是被如何调用的，都可以断言它是可重入的。

我们总是使用术语可重入的(reentrant ) 既包括显式可重人函数也包括隐式可重入函数。 然而, 认识到可重入性有时既是调用者也是被调用者的属性 , 并不只是被调用者单独的属性是非常重要的。

### 2.3 race (竞争)


### 2.4 死锁(deadlock)

信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁(deadlock),它是指一组线程被柱塞了，等待一个永远不会为真的条件。

- 程序员使用$P$和$V$操作顺序不当，以至于两个信号量的禁止区域重叠。如果某个执行轨迹碰巧到达了死锁状态,那么就不可能有进一步的进展了。换句话说，程序死锁是因为每个线程都在等待其他线程执行一个根本不可能发生的$V$操作。

- 重叠的禁止区域引起了一组称为死锁区域(deadlock region)的状态。如果一个轨迹线碰巧达到了一个死锁区域中的状态，那么死锁就是不可避免的了。 

- 死锁是一个相当困难的问题，因为它不总是可预测的。

**使用二元信号量来实现互斥是，可以用如下规则来避免死锁:**

互斥锁加锁顺序规则: 给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。
